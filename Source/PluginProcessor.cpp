/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
ChorusAudioProcessor::ChorusAudioProcessor()
{
	// Set inital values for all input variables
	delayTime = 0.02;
	modRate = 0.5;
	depth = 1.0;
	wetDry = 0.5;
	int x = 0;
}

ChorusAudioProcessor::~ChorusAudioProcessor()
{
}

//==============================================================================
const String ChorusAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool ChorusAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool ChorusAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool ChorusAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double ChorusAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int ChorusAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int ChorusAudioProcessor::getCurrentProgram()
{
    return 0;
}

void ChorusAudioProcessor::setCurrentProgram (int index)
{
}

const String ChorusAudioProcessor::getProgramName (int index)
{
    return String();
}

void ChorusAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void ChorusAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void ChorusAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void ChorusAudioProcessor::LFOBuffer()
{
	for (int i = 0; i < FS; i++)
	{
		// Creates an audio buffer that holds a sine wave
		// of the frequency and amplitude set by the user
		float t = (float)i / (float)FS;
		float sinx = sin(2 * pi * modRate * t);
		depthOSCwp[i] = depth * sinx;
	}
}

double ChorusAudioProcessor::interpolateLinear(double y0, double y1, double x, double x0)
{
	// Applies linear interpolation with the equation y = y0 + (y1-y0)*((x-x0)/(x1-x0))
	// since we are working with samples x1-x0 = 1 so has been excluded here
	double y;
	y = y0 + (y1 - y0) * (x-x0);
	return y;
}

void ChorusAudioProcessor::resizeBuffers(AudioSampleBuffer& depthOSC, AudioSampleBuffer& delayOSC, AudioSampleBuffer& delayBufferL, AudioSampleBuffer& delayBufferR)
{
	// Set the size all the buffers to be the same as the current sample rate
	// this is equivalent to 1 second
	delayBufferL.setSize(1, (int)getSampleRate(), false, true, true);
	delayBufferR.setSize(1, (int)getSampleRate(), false, true, true);
	depthOSC.setSize(1, (int)getSampleRate(), false, true, true);
	delayOSC.setSize(1, (int)getSampleRate(), false, true, true);

	// Update stored sample rate.
	FS = getSampleRate();

	// Update write pointers
	depthOSCwp = depthOSC.getWritePointer(0);
	delayOSCwp = delayOSC.getWritePointer(0);
	delayBufferLwp = delayBufferL.getWritePointer(0);
	delayBufferRwp = delayBufferR.getWritePointer(0);

	// Update read pointers
	depthOSCrp = depthOSC.getReadPointer(0);
	delayOSCrp = delayOSC.getReadPointer(0);
	delayBufferLrp = delayBufferL.getReadPointer(0);
	delayBufferRrp = delayBufferR.getReadPointer(0);
	LFOBuffer();

	// Update buffer index
	bidx = 0;
}

void ChorusAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

	// If the sample rate has changed resize the buffers
	if (FS != getSampleRate())resizeBuffers(depthOSC, delayOSC, delayBufferL, delayBufferR);

	// If the modulation rate or the depth have been changed recreate LFO
	if (freq != modRate || Amp != depth)LFOBuffer();

	// get current write pointers
	depthOSCwp = depthOSC.getWritePointer(0);
	delayOSCwp = delayOSC.getWritePointer(0);
	delayBufferLwp = delayBufferL.getWritePointer(0);
	delayBufferRwp = delayBufferR.getWritePointer(0);

	// get current read pointers
	depthOSCrp = depthOSC.getReadPointer(0);
	delayOSCrp = delayOSC.getReadPointer(0);
	delayBufferLrp = delayBufferL.getReadPointer(0);
	delayBufferRrp = delayBufferR.getReadPointer(0);
		
	// Calculate delay in samples
	int delay = (int)(delayTime*FS);


	// create input and output channels to read from and write to
	const float *inL = buffer.getReadPointer(0);
	const float *inR = buffer.getReadPointer(1);
	float *outL = {};
	outL = buffer.getWritePointer(0);
	float *outR = {};
	outR = buffer.getWritePointer(1);

	// Step through each sample in the current buffer
	for (int i = 0; i < buffer.getNumSamples(); i++)
	{

		// Calculate the delay point, and write to delay buffer
		double dSamp = i + bidx - delay;

		// Current sample for the delay buffer
		int ridx = i + bidx;
		
		// Wrap ridx if it is larger than the size of the delay buffer (equal to the sample rate)
		if (ridx >= FS)ridx -= FS;

		// Calculate delay after modulation has been applied
		double modDelay = (delay * 0.3 * depthOSCrp[ridx]); 
		double dSampMod = dSamp - modDelay;

		// If the delay time exceeds or is under the buffer length wrap around
		if ((int)dSampMod < 0)dSampMod += FS;
		if ((int)dSampMod >= FS)dSampMod -= FS;

		double delaySampleL = 0;
		double delaySampleR = 0;

		// write current input data to delayBuffer
		delayBufferRwp[ridx] = inR[i];
		delayBufferLwp[ridx] = inL[i];

		// Check whether the delay is fractional
		double dSampModround = round(dSampMod);
		double check = dSampMod - dSampModround;
		int inc = 0;

		// If the fractional content of the delay is > 0 then interpolate against the next sample
		// If the fractional ocntent of the delay is < 0 then interpolate against the previous sample
		// Else take the current sample without interpolation
		if (check > 0)
		{
			inc = (int)dSampModround+1;
			
			if (inc >= FS)
			{
				delaySampleL = interpolateLinear(delayBufferLrp[int(dSampMod)], delayBufferLrp[inc-FS], dSampMod, round(dSampMod));
				delaySampleR = interpolateLinear(delayBufferRrp[int(dSampMod)], delayBufferRrp[inc - FS], dSampMod, round(dSampMod));
			}
			else
			{
				delaySampleL = interpolateLinear(delayBufferLrp[int(dSampMod)], delayBufferLrp[inc], dSampMod, round(dSampMod));
				delaySampleR = interpolateLinear(delayBufferRrp[int(dSampMod)], delayBufferRrp[inc], dSampMod, round(dSampMod));
			}
		}
		else if (check < 0)
		{
			inc = (int)dSampModround-1;
			
			if (inc < 0)
			{
				delaySampleL = interpolateLinear(delayBufferLrp[inc + FS], delayBufferLrp[int(dSampMod)], dSampMod, inc);
				delaySampleR = interpolateLinear(delayBufferRrp[inc + FS], delayBufferRrp[int(dSampMod)], dSampMod, inc);
			}
			else
			{
				delaySampleL = interpolateLinear(delayBufferLrp[inc], delayBufferLrp[int(dSampMod)], dSampMod, inc);
				delaySampleR = interpolateLinear(delayBufferRrp[inc], delayBufferRrp[int(dSampMod)], dSampMod, inc);
			}
		}
		else
		{
			delaySampleL = delayBufferLrp[int(dSampMod)];
			delaySampleR = delayBufferRrp[int(dSampMod)];
		}

		// Add the delayed sample to the current sample
		// Weight each sample against how much of the wet/dry mix has been select
		outL[i] = ((1 - wetDry)*inL[i] + wetDry*delaySampleL)*0.5;
		outR[i] = ((1 - wetDry)*inR[i] + wetDry*delaySampleR)*0.5;

	}

	// Increment index in relation to where the current buffer will be placed within the delay buffer
	// wrap bidx if greater than sample rate
	bidx += buffer.getNumSamples();
	if (bidx >= FS)bidx -= FS;

	// store current freqency and modulation rates
	freq = modRate;
	Amp = depth;
}

//==============================================================================
bool ChorusAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* ChorusAudioProcessor::createEditor()
{
    return new ChorusAudioProcessorEditor (*this);
}

//==============================================================================
void ChorusAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void ChorusAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new ChorusAudioProcessor();
}
